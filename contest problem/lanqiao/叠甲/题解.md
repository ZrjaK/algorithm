### 解题思路

前置知识：矩阵乘法、线段树。

由于数据范围很大，每次修改的时间复杂度需要控制在 $O(\log n)$ 的级别。

发现每次运算都是线性的，所以可以使用矩阵乘法来表示每次运算。

技能 $1$ ： 

$$a = k_1 \times a + b$$ 

$$\Downarrow $$

$$
\begin{bmatrix} 
a & b
\end{bmatrix}
\begin{bmatrix}
 k_1 & 0 \\
 1 & 1
\end{bmatrix} = 
\begin{bmatrix}
k_1 \times a + b & b
\end{bmatrix}
$$

技能 $2$ ： 

$$b = a + k_2 \times b$$

$$\Downarrow $$

$$
\begin{bmatrix} 
a & b
\end{bmatrix}
\begin{bmatrix}
 1 & 1 \\
 0 & k_2
\end{bmatrix} = 
\begin{bmatrix}
a & a + k_2 \times b
\end{bmatrix}
$$

在样例一中：$s = 001$ ，对应的式子是：

$$
\begin{bmatrix} 
1 & 2
\end{bmatrix}
\begin{bmatrix}
 3 & 0 \\
 1 & 1
\end{bmatrix}
\begin{bmatrix}
 3 & 0 \\
 1 & 1
\end{bmatrix}
\begin{bmatrix}
 1 & 1 \\
 0 & 4
\end{bmatrix} = 
\begin{bmatrix}
17 & 25
\end{bmatrix}
$$

由于矩阵运算具有结合律，可以先计算后面三个矩阵相乘结果，最后再左乘 $
\begin{bmatrix} 
a & b
\end{bmatrix}
$ 。

使用线段树来维护每个位置的矩阵，每次询问相当于单点修改，区间查询。

时间复杂度 $O(2^3(n+q)\log n)$ 。

### AC Code
- C++
```cpp
#include <bits/stdc++.h>

using namespace std;

template <class S,
          S (*op)(S, S),
          S (*e)()>
struct segtree {
  public:
    segtree() : segtree(0) {}
    segtree(int n) : segtree(std::vector<S>(n, e())) {}
    segtree(const std::vector<S>& v) : _n(int(v.size())) {
        log = 0;
        while ((1 << log) < _n) ++log;
        size = 1 << log;
        d = std::vector<S>(2 * size, e());
        for (int i = 0; i < _n; i++) d[size + i] = v[i];
        for (int i = size - 1; i >= 1; i--) {
            update(i);
        }
    }

    void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        d[p] = x;
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    S all_prod() { return d[1]; }

  private:
    int _n, size, log;
    std::vector<S> d;

    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
};

const int MOD = 1e9 + 7;

struct Info {
    long long a[2][2];
    Info () {
        memset(a, 0, sizeof(a));
        a[0][0] = a[1][1] = 1;
    }

    Info (int x, int f) {
        memset(a, 0, sizeof(a));
        if (f == 0) a[0][0] = x, a[1][0] = a[1][1] = 1;
        else a[0][0] = a[0][1] = 1, a[1][1] = x;
    }
};

Info op(Info a, Info b) {
    Info c;
    memset(c.a, 0, sizeof(c.a));
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 2; k++) {
                c.a[i][k] = (c.a[i][k] + a.a[i][j] * b.a[j][k]) % MOD;
            }
        }
    }
    return c;
}

Info e() {
    return Info();
}

void solve() {
    long long n, A, B, k1, k2;
    cin >> n >> A >> B >> k1 >> k2;
    string s;
    cin >> s;
    segtree<Info, op, e> seg(n);
    for (int i = 0; i < n; i++) {
        if (s[i] == '0') seg.set(i, Info(k1, 0));
        else seg.set(i, Info(k2, 1));
    }
    int q;
    cin >> q;
    for (int i = 0; i < q; i++) {
        int x;
        cin >> x;
        x--;
        if (s[x] == '1') {
            s[x] = '0';
            seg.set(x, Info(k1, 0));
        } else {
            s[x] = '1';
            seg.set(x, Info(k2, 1));
        }
        Info res = seg.all_prod();
        long long a = (res.a[0][0] * A % MOD + res.a[1][0] * B % MOD) % MOD;
        long long b = (res.a[0][1] * A % MOD + res.a[1][1] * B % MOD) % MOD;
        cout << a << " " << b << "\n";
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

- Python3
```python
n, A, B, k1, k2 = map(int, input().split())
s = list(input())

class segtree():
  def __init__(self,init,func,ide):
    self.n=len(init)
    self.func=func
    self.ide=ide
    self.size=1<<(self.n-1).bit_length()
    self.tree=[self.ide for i in range(2*self.size)]
    for i in range(self.n):
      self.tree[self.size+i]=init[i]
    for i in range(self.size-1,0,-1):
      self.tree[i]=self.func(self.tree[2*i], self.tree[2*i|1])
  
  def update(self,k,x):
    k+=self.size
    self.tree[k]=x
    k>>=1
    while k:
      self.tree[k]=self.func(self.tree[2*k],self.tree[k*2|1])
      k>>=1
  
  def get(self,i):
    return self.tree[i+self.size]
  
  def query(self,l,r):
    l+=self.size
    r+=self.size
    l_res=self.ide
    r_res=self.ide
    while l<r:
      if l&1:
        l_res=self.func(l_res,self.tree[l])
        l+=1
      if r&1:
        r-=1
        r_res=self.func(self.tree[r],r_res)
      l>>=1
      r>>=1
    return self.func(l_res,r_res)
 
  def __iter__(self):
    for i in range(self.n):
      yield self.tree[i+self.size]
          
  def __str__(self):
    return str(list(self))

def fun(a, b):
    res = [[0, 0], [0, 0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                res[i][k] += a[i][j] * b[j][k]
                res[i][k] %= int(1e9 + 7)
    return res

def idle():
    res = [[1, 0], [0, 1]]
    return res

seg = segtree([idle() for _ in range(n)], fun, idle())

for i in range(n):
    if s[i] == "0":
        seg.update(i, [[k1, 0], [1, 1]])
    else:
        seg.update(i, [[1, 1], [0, k2]])
        

q = int(input())
out = []

for _ in range(q):
    x = int(input()) - 1
    if s[x] == "1":
        s[x] = "0"
        seg.update(x, [[k1, 0], [1, 1]])
    else:
        s[x] = "1"
        seg.update(x, [[1, 1], [0, k2]])
    res = seg.tree[1]
    a = A * res[0][0] + B * res[1][0]
    a %= int(1e9 + 7)
    b = A * res[0][1] + B * res[1][1]
    b %= int(1e9 + 7)
    out.append(str(a) + " " + str(b))

print("\n".join(out))
```